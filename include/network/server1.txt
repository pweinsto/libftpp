#ifndef SERVER_HPP
#define SERVER_HPP

#include <string>
#include <functional>
#include <unordered_map>
#include <vector>
#include "message.hpp"

/**
 * @brief A stub Server class that pretends to start on a given port, 
 * handle multiple clients, route messages, and invoke user actions.
 */
class Server
{
public:
    Server() = default;
    ~Server() = default;

    /**
     * @brief Start the server at the specified port.
     */
    void start(const size_t& p_port);

    /**
     * @brief Register a callback/action for a particular message type.
     *
     * @param messageType The type of message to listen for.
     * @param action      The function to call when such a message arrives.
     */
    void defineAction(const Message::Type& messageType,
                      const std::function<void(long long& clientID, const Message& msg)>& action);

    /**
     * @brief Send a message to a specific client.
     */
    void sendTo(const Message& message, long long clientID);

    /**
     * @brief Send a message to a list of client IDs.
     */
    void sendToArray(const Message& message, std::vector<long long> clientIDs);

    /**
     * @brief Send a message to all connected clients.
     */
    void sendToAll(const Message& message);

    /**
     * @brief Process all messages received since the last update call and
     *        execute the subscribed user actions.
     */
    void update();

private:
    bool m_running = false;

    // Maps message types to user-defined (clientID, Message) callbacks
    std::unordered_map<Message::Type, std::function<void(long long&, const Message&)>> m_actions;

    // Pretend we have a list of connected client IDs
    std::vector<long long> m_clients;

    // Messages that the server "has received" from each client
    std::vector<std::pair<long long, Message>> m_receivedMessages;

    // Outgoing messages that the server wants to send to clients
    std::vector<std::pair<long long, Message>> m_outgoing;
};

#endif
