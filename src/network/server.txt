#include "../../include/network/server.hpp"
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <poll.h>

Server::Server() : server_fd_(-1), running_(false) {}

Server::~Server() {
    if (running_) {
        close(server_fd_);
    }
}

void Server::start(const size_t& port) {
    server_fd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd_ < 0) {
        std::cerr << "Error opening socket" << std::endl;
        return;
    }

    server_addr_.sin_family = AF_INET;
    server_addr_.sin_port = htons(port);
    server_addr_.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_fd_, (struct sockaddr*)&server_addr_, sizeof(server_addr_)) < 0) {
        std::cerr << "Binding failed" << std::endl;
        return;
    }

    listen(server_fd_, 5);
    running_ = true;
    std::cout << "Server started on port " << port << std::endl;

    while (running_) {
        struct pollfd fds[client_fds_.size() + 1];
        fds[0].fd = server_fd_;
        fds[0].events = POLLIN;

        for (size_t i = 0; i < client_fds_.size(); ++i) {
            fds[i + 1].fd = client_fds_[i];
            fds[i + 1].events = POLLIN;
        }

        int ret = poll(fds, client_fds_.size() + 1, -1);

        if (ret > 0) {
            if (fds[0].revents & POLLIN) {
                // Accept new connection
                int new_client_fd = accept(server_fd_, NULL, NULL);
                if (new_client_fd >= 0) {
                    client_fds_.push_back(new_client_fd);
                }
            }

            // Process messages from clients
            for (size_t i = 0; i < client_fds_.size(); ++i) {
                if (fds[i + 1].revents & POLLIN) {
                    // Receive message type
                    int type;
                    ssize_t received = recv(client_fds_[i], &type, sizeof(type), 0);
                    if (received <= 0) continue;

                    Message message(type);
                    while (true) {
                        char buffer[1024];
                        received = recv(client_fds_[i], buffer, sizeof(buffer), 0);
                        if (received <= 0) break;
                        message << std::string(buffer, received);
                    }

                    // Execute the appropriate action
                    if (type >= 0 && type < actions_.size() && actions_[type]) {
                        actions_[type](client_fds_[i], message);
                    }
                }
            }
        }
    }
}

void Server::defineAction(const Message::Type& messageType, const std::function<void(long long&, const Message&)>& action) {
    if (actions_.size() <= messageType) {
        actions_.resize(messageType + 1);
    }
    actions_[messageType] = action;
}

void Server::sendTo(const Message& message, long long clientID) {
    send(clientID, &message, sizeof(message), 0);
}

void Server::sendToArray(const Message& message, std::vector<long long> clientIDs) {
    for (long long clientID : clientIDs) {
        sendTo(message, clientID);
    }
}

void Server::sendToAll(const Message& message) {
    for (int client_fd : client_fds_) {
        sendTo(message, client_fd);
    }
}

void Server::update() {
    // This could be a polling loop, but is included in the server loop already
}