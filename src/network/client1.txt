#include "../../include/network/client.hpp"
#include <iostream>

void Client::connect(const std::string& address, const size_t& port)
{
    // Stub: pretend to connect
    m_connected = true;
    std::cout << "[Client] Connected to " << address << ":" << port << std::endl;
}

void Client::disconnect()
{
    if (m_connected) {
        // Stub: pretend to disconnect
        m_connected = false;
        std::cout << "[Client] Disconnected.\n";
    }
}

void Client::defineAction(const Message::Type& messageType,
                          const std::function<void(const Message&)>& action)
{
    m_actions[messageType] = action;
}

void Client::send(const Message& message)
{
    if (!m_connected) {
        std::cout << "[Client] Cannot send. Not connected.\n";
        return;
    }

    // Stub: In a real client, you would serialize and send the message over the network.
    // Here, we just keep it in a vector to simulate "server-bound" messages.
    std::cout << "[Client] Queued message of type " << message.type() << "\n";
    m_toSend.push_back(message);
}

void Client::update()
{
    if (!m_connected) {
        return;
    }

    // ----------------------------------------------------------------------------
    //  STUB MECHANISM:
    //  In a real client, you would:
    //    1. Check the socket for any incoming data
    //    2. Deserialize that data into Message objects
    //    3. Push them into `m_received`
    //    4. Call the appropriate actions below
    //
    //  In this stub, we simulate a scenario:
    //    - If we sent a message of type=1 with an int, we pretend the server
    //      immediately responds with a type=3 message containing the doubled int.
    // ----------------------------------------------------------------------------

    // "Fake server" response: for each message of type=1, produce a type=3 with doubled integer
    for (auto &msg : m_toSend) {
        if (msg.type() == 1) {
            int value;
            msg >> value;  // read the original value
            // simulate a "server" reply:
            Message reply(3);
            reply << (value * 2);
            m_received.push_back(reply);
        }
        else if (msg.type() == 2) {
            // The server might not respond for type=2, so do nothing here
        }
    }
    // In a real client, the above would happen on the server side, 
    // but we are stubbing it out here for demonstration.
    m_toSend.clear();

    // Now process any newly "received" messages
    for (auto &incoming : m_received) {
        auto it = m_actions.find(incoming.type());
        if (it != m_actions.end()) {
            it->second(incoming);  // call the user-defined action
        }
    }
    m_received.clear();
}
